from numpy.random import randint
from numpy.random import uniform 
from numpy.random import exponential
from population   import Individual
from population   import Population
from numpy        import array
from numpy        import loadtxt
from numpy        import savetxt
from heapq        import heappop
from heapq        import heappush
from time         import time
from sys          import exit, argv
from copy 		  import deepcopy
import random
import os

class DifferentialEvolution:

	def __init__(self, np, cr, jr, f, algorithm, change):
		self.__np         = np
		self.__cr         = cr
		self.__jr		  = jr
		self.__f          = f
		self.__criteria_of_change = change
		self.__algorithm  = None
		self.__population = []
		self.__opposite   = []
		self.__crosstype  = None
		self.__best_solution = None
		self.__total_time = None
		self.__population_data = []
		self.__aux_list = []
		self.__selected_to_change = {'indv': None, 'indexes': None}
		
	
		if callable(getattr(self, algorithm, None)):
			self.__algorithm = getattr(self, algorithm, None)
			self.__crosstype = algorithm.split('_')[-1]

		else:
			print('\nERROR:\n\tDE algorithm \'{}\' is not available.'.format(algorithm))
			exit(-1)

	def heap_sort(self, population):

		heap = []
		for individual in population:
			heappush(heap, individual)

		ordered = []
		while heap:
			ordered.append(heappop(heap))

		return ordered
	

	def evaluate(self):

		for individual in self.__population:
			self.__population_data.append(individual.get())

		savetxt(os.path.join(os.getcwd(), 'tools', 'grief', 'test_pairs.txt'), self.__population_data, delimiter=' ', fmt='%s')
		
		#Função de avaliação
		cmd = "./tools/evaluate GRIEF-datasets/planetarium"
		os.system(cmd)
	
		evaluation = loadtxt(os.path.join(os.getcwd(), 'tools', 'grief', 'evaluation.txt'), delimiter=' ', dtype=int)
		return int(evaluation)


	def opposite_evaluate(self):
			
		opposite_data = []
		for individual in self.__population:
			opposite_data.append(individual.get())

		os.system("cp ./tools/grief/pair_stats.txt ./tools/grief/pair_stats.bak")
		os.system("cp store.tmp store.bak")

		savetxt(os.path.join(os.getcwd(), 'tools', 'grief', 'test_pairs.txt'), opposite_data, delimiter=' ', fmt='%s')

		os.system("./tools/generate_eval.sh ")
		
		#Função de avaliação
		cmd = "./tools/evaluate GRIEF-datasets/planetarium"
		os.system(cmd)

		# os.system("cp ./tools/grief/test_pairs.txt ./tools/grief/opposite_test_pairs.txt")
		# os.system("cp ./tools/grief/pair_stats.txt ./tools/grief/opposite_pair_stats.txt")

		
		# # restaura pair_stats
		# os.system("cp ./tools/grief/test_pairs.bak ./tools/grief/test_pairs.txt")
		# os.system("cp ./tools/grief/pair_stats.bak ./tools/grief/pair_stats.txt")
		


	def evaluate_new_population(self):

		population_data = []
		for individual in self.__population:
			population_data.append(individual.get())

		# replace individuals by new ones generated by DE in the original population
		for index, individual in zip(self.__selected_to_change['indexes'], self.__aux_list):
			population_data[index] = individual.get()

		os.system("cp ./tools/grief/pair_stats.txt ./tools/grief/pair_stats.bak")
		os.system("cp store.tmp store.bak")
		savetxt(os.path.join(os.getcwd(), 'tools', 'grief', 'test_pairs.txt'), population_data, delimiter=' ', fmt='%s')
		
		os.system("./tools/generate_eval.sh ")

		#Função de avaliação
		cmd = "./tools/evaluate GRIEF-datasets/planetarium| grep fitness > store.tmp"
		os.system(cmd)


		evaluation = int(loadtxt(os.path.join(os.getcwd(), 'tools', 'grief', 'evaluation.txt'), delimiter=' ', dtype=int))
		
		return evaluation
	
	def select_individuals(self):

		key, n = self.__criteria_of_change

		self.__selected_to_change['indexes'] = []
		self.__selected_to_change['indv']    = []

		if key == 'rand':
			indexes = random.sample(range(0, 511), n)
			self.__selected_to_change['indexes'] = indexes

			for i in indexes:
				self.__selected_to_change['indv'].append(self.__population[i])
		
		elif key == 'worst':
			self.__selected_to_change['indv']    = self.__population[-n:]
			self.__selected_to_change['indexes'] = [i for i in range(self.__np)][-n:]


	def evolve(self, g):
		
		ti = time()

		population = Population(np=self.__np)
		self.__population = population.create()
		self.__previous_fit = self.evaluate()

		###########################
		# Opposite-Based Learning #
		###########################


		if g == 1: #or self.__jr >= uniform()
			
			# print("Entrando em Opposite-Based Learning")

			# select individuals who will be used as opposite
			self.select_individuals()

			opposite_individuals = population.opposite(self.__selected_to_change['indv'])

			for index, individual in zip(self.__selected_to_change['indexes'], opposite_individuals):
				self.__population[index] = individual

			e = self.evaluate()
			# evaluate here
			# self.opposite_evaluate()

			# opposite_population_data = loadtxt(os.path.join(os.getcwd(), 'tools', 'grief', 'opposite_pair_stats.txt'), delimiter=' ', dtype=int)

			# for individual, data in zip(self.__opposite, opposite_population_data):
			# 	individual.set(array(data[:-1]))
			# 	individual.set_fit(data[-1])

			# temp = []
			# temp = self.__population

			# for opindv in self.__opposite:
			# 	temp.append(opindv)

			# new_population = []
			# new_population = self.heap_sort(temp)

			# new_population_data = []
			# for individual in new_population[:self.__np]:
			# 	new_population_data.append(individual.get())
			
			# # os.system("cp ./tools/grief/pair_stats.bak ./tools/grief/pair_stats.txt")
			# savetxt(os.path.join(os.getcwd(), 'tools', 'grief', 'test_pairs.txt'), new_population_data, delimiter=' ', fmt='%s')
			# os.system("./tools/generate_eval.sh ")

			# del(temp)
			# del(new_population)
			# del(new_population_data)

		###########################
		else:

			# print("Entrando no else. Param: {} {}".format(self.__criteria_of_change[0], self.__criteria_of_change[1]))

			self.select_individuals()

			for index, individual in zip(self.__selected_to_change['indexes'], self.__selected_to_change['indv']):
				
				# mutation
				mutated_vector = self.mutate(index)

				# crossover
				new_individual = Individual()
				new_individual.create()

				u = self.crossover(individual, mutated_vector)
				new_individual.set(array(u))

				self.__aux_list.append(new_individual)
				
				# self.__population_data[index] = u

			
			# selection
			evaluation = self.evaluate_new_population()

			if self.__previous_fit > evaluation:

				os.system("cp store.bak store.tmp")
				
				# for index, individual in zip(self.__selected_to_change['indexes'], self.__aux_list):
				# 	self.__population_data[index] = individual.get()

				# counter = 0
				# for i in self.__selected_to_change:
				# 	self.__population_data[i] = self.__aux_list[counter]
				# 	counter+=1
				# self.__aux_list = []
				
				os.system("cp ./tools/grief/pair_stats.bak ./tools/grief/pair_stats.txt")
				savetxt(os.path.join(os.getcwd(), 'tools', 'grief', 'test_pairs.txt'), self.__population_data, delimiter=' ', fmt='%s')

				os.system("./tools/generate_eval.sh ")

				print(f'a anterior foi {self.__previous_fit} e a nova  foi {evaluation} não mudou')
			else:
				print(f'a anterior foi {self.__previous_fit} e a nova  foi {evaluation} mudou')
				self.__previous_fit = evaluation
				self.__aux_list = []

		self.__opposite.clear()

		# os.system("rm ./tools/grief/opposite_pair_stats.txt ./tools/grief/opposite_test_pairs.txt")


		tf = time()	  
		self.__total_time =  tf - ti


	def mutate(self, i):
		return self.__algorithm(i)

	def crossover(self, individual, mutated_vector):

		call = None
		if self.__crosstype == 'exp':
			call = exponential
		elif self.__crosstype == 'bin':
			call = uniform 
		
		J = randint(0, self.__np)

		u = []
		for j, value in enumerate(individual.get()):
			r = float(format(call(), '.1f'))
			if r < self.__cr or j == J:
				u.append(int(mutated_vector[j]))
			else:
				u.append(int(value))

		return u

	def get_best(self):

		best = self.__population[0]
		# for indv in self.__population:
		#     if indv.get_fit() < best.get_fit():
		#         best = indv

		return best
	
	def get_best_solution(self):
		return self.__best_solution

	def get_execution_time(self):
		return self.__total_time

	def rand_1_bin(self, i):

		''' Vi,G = Vr1,G + F (Vr2,G - Vr3,G) '''

		indexes = []
		indexes.append(i)     
		while len(indexes) <= 4:
			r = randint(0, self.__np)
			if not r in indexes:
				indexes.append(r)

		r1, r2, r3 = indexes[1], indexes[2], indexes[3]

		v = self.__population[r1].get() + self.__f * (self.__population[r2].get() - self.__population[r3].get())

		for j, a in enumerate(v):
			
			if a >= 0:
				v[j] = a%25
			else:
				v[j] = -(abs(a)%25)

		return v


	def rand_2_bin(self, i):

		''' Vi,G = Vr1,G + F (Vr2,G - Vr3,G + Vr4,G – Vr5,G) '''

		indexes = []
		indexes.append(i)     
		while len(indexes) <= 6:
			r = randint(0, self.__np)
			if not r in indexes:
				indexes.append(r)

		r1, r2, r3, r4, r5 = indexes[1], indexes[2], indexes[3], indexes[4], indexes[5]

		v = self.__population[r1].get() + self.__f * ((self.__population[r2].get() - self.__population[r3].get()) + (self.__population[r4].get() - self.__population[r5].get()))

		for j, a in enumerate(v):
			
			if a >= 0:
				v[j] = a%25
			else:
				v[j] = -(abs(a)%25)

		return v


	def randtobest_1_bin(self, i):
		
		''' Vi,G = Vr1,G + F (Vbest,G – Vr1,G + Vr2,G – Vr3,G) '''

		best = self.__population.index(self.get_best())

		indexes = []
		indexes.append(i)   
		indexes.append(best)  

		while len(indexes) <= 5:
			r = randint(0, self.__np)
			if not r in indexes:
				indexes.append(r)

		r1, r2, r3 = indexes[1], indexes[2], indexes[3]  

		v = self.__population[r1].get() + self.__f * (( self.__population[best].get() - self.__population[r1].get()) + (self.__population[r2].get() - self.__population[r3].get()))
		
		for j, a in enumerate(v):
			
			if a >= 0:
				v[j] = a%25
			else:
				v[j] = -(abs(a)%25)

		return v


	def rand_2_exp(self):
		pass

	def best_1_bin(self, i):
		
		''' Vi,G = Vbest,G + F (Vr2,G - Vr3,G) '''

		best = self.__population.index(self.get_best())

		indexes = []
		indexes.append(i)   
		indexes.append(best)  

		while len(indexes) <= 4:
			r = randint(0, self.__np)
			if not r in indexes:
				indexes.append(r)

		r2, r3 = indexes[2], indexes[3]  

		v = self.__population[best].get() + self.__f * (self.__population[r2].get() - self.__population[r3].get())
		
		for j, a in enumerate(v):
			
			if a >= 0:
				v[j] = a%25
			else:
				v[j] = -(abs(a)%25)

		return v


	def best_2_exp(self):
		pass

	def currenttobest_1_bin(self, i):

		''' Vi,G = Vi,G + F (Vbest,G – Vi,G + Vr2,G – Vr3,G) '''

		best = self.__population.index(self.get_best())
		current = i

		indexes = []
		indexes.append(current)   
		indexes.append(best)
		
		while len(indexes) <= 4:
			r = randint(0, self.__np)
			if not r in indexes:
				indexes.append(r)

		r2, r3 = indexes[2], indexes[3]
		
		v = self.__population[current].get() + self.__f * ((self.__population[best].get() - self.__population[current].get()) + (self.__population[r2].get() - self.__population[r3].get()))

		for j, a in enumerate(v):
			
			if a >= 0:
				v[j] = a%25
			else:
				v[j] = -(abs(a)%25)

		return v

	def currenttorand_1_bin(self, i):
		
		''' Vi,G = Vi,G + F (Vr1,G – Vi,G + Vr2,G – Vr3,G) '''
		
		current = i

		indexes = []
		indexes.append(current)   
		
		while len(indexes) <= 4:
			r = randint(0, self.__np)
			if not r in indexes:
				indexes.append(r)

		r1, r2, r3 = indexes[1], indexes[2], indexes[3]        

		v = self.__population[current].get() + self.__f * ((self.__population[r1].get() - self.__population[current].get()) + (self.__population[r2].get() - self.__population[r3].get()))

		for j, a in enumerate(v):
			
			if a >= 0:
				v[j] = a%25
			else:
				v[j] = -(abs(a)%25)
				
		return v



if __name__ == '__main__':


	change_criteria = ['worst', 20]
	arg = int(argv[1])

	de = DifferentialEvolution(
		np=512,
		cr=0.8, 
		jr=0.3,
		f=0.6, 
		algorithm='rand_1_bin',
		change=change_criteria
	)
	de.evolve(g=arg)	
	